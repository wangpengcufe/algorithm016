**四件套：**
- 1、问清楚题目的意思(和面试官多确认几次题目的边界条件，意思)
- 2、尽可能多的方法解决
- 3、找出最佳的时间，空间复杂度的算法
- 4、测试

**做完一遍的后续：**
- 5、尝试用python和java不同语言去解决
- 6、写题解思路
- 7、阅读国内和国际的top题解和most votes
- 8、总结最佳题解
- 9、五毒神掌
- 10、分享


**五毒神掌:**
- 第一遍：5分钟读题+思考；直接看题解，多比较，比较解法优劣；背诵，默写好的解法。
- 第二遍：马上自己写，leeCode提交，体会，优化
- 第三遍：过了一天后，重复做题，不同解法的熟练程度->专项训练
- 第四遍：过了一周，反复回来练习相同的题目
- 第五遍：面试前一周恢复性训练


**算法的思想：**
- 1.优化的思想：空间换时间
- 2.找最近重复子问题

**git的使用方法：**
1、fork仓库
2、克隆至本地编辑
3、配置Git，进行用户名和邮箱配置
4、配置公私钥
5、克隆仓库

git常用命令：
```
    git status  # 查询状态，会提示是否有文件未提交
    git log     # 查看提交的历史记录（谁，什么时候，提交了什么）
    ssh -T git@github.com  # 验证远程服务器是否连接成功
    git --version    # 查看是否安装成功
    git init         # 初始化
    ls -al           # 查看操作
    git config --global user.name "username"   # 配置用户名
    git config --global user.email "email"     # 配置邮箱
    git config --global --list   # 检查配置的信息
    ssh-keygen -t rsa -C "email"   # 生成密钥
    配置公钥至服务器
    git clone git@github.com:wangpengcufe/algorithm016.git   # 克隆fork的副本到本地
    git add .  # 将代码从工作区移到缓存区
    git commit -m "注释内容"  # 更新的注释，将文件从缓存区提到仓库区
    git push -u origin master  # 将本地的master分支推送到origin主机 # 注意，改了哪个文件，要在哪个文件的路径下提交！
```

**自顶向下：**
- 自顶向下的编码方式，新闻稿一样，头条放最上面，次条放下面；先写出最主要的枝干，其余方法直接写名称

**解题思路：**
- 加1：
 - 1、从末尾开始往前循环遍历，末尾开始加1，如果加1之后，能够被10整除，那么继续遍历至前一位，继续加1；如果不能被10整除，那么停止遍历，返回加1后的结果。
 - 2、特殊情况，如果，所有位置都遍历完后，都能被10整除，那么需要将数组扩充1位，首位位1，其余皆为0.
 - 3、判断每一位上是否为9。如果不为9的话，那么加1，然后直接返回结果，完成加1运算；如果为9的话，那么就将它改成0，继续下一次循环，循环的出口还是找到不为9的数字。如果循环结束，还没找出出口的话，那么就新开辟一个数组，将数组的长度加1，首位置为1，其余为0，返回结果。

- 两数之和：
 - 1、暴力求解法：两层遍历：第一层遍历，先遍历数组中的每一个元素；第二层遍历，拿着当前的元素去和剩下的每一个元素进行加和，如果等于target，则返回下标。
 - 2、用哈希表求解，遍历一次，如果不存在target，则存到哈希表中，如果找到了，则返回结果。
 
- 爬楼梯：
 - 1、自顶向下
 - 2、斐波那契数列
 
** 链表知识：**
- 1、存储：链表是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)
- 2、插入：由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多
- 3、查找：查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)
- 4、优点：使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。
- 5、缺点：链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

**Array和Linked List的总结：**
- 1、Array在内存中开辟了一个内存地址，随机访问哪个元素时间都一样，都是O（1），这是数组的优点之一，访问很快。
- 2、Linked List 的数据结构，弥补了Array在频繁插入，删除的情况下的缺点。有value和next
- 3、Linked List 的每一个元素用class来定义，这里的class叫 node
- 4、头指针叫head， 尾指针叫tail，指向None； 尾指针指向head的叫循环列表。
- 5、增加操作，时间复杂度O（1），指针指向新的节点，新的节点的指针指向下一个元素。
- 6、删除，把前驱节点的next打掉，移到后继的节点去。
- 7、优点：增加删除，没有引起整个链表的群移操作，也不需要复制元素，移动一半的元素。所以，移动效率和修改操作的效率是非常高的，O（1）。
- 8、缺点：访问操作，要从头head往后移动，线性n，O（n）的时间复杂度。
- 9、Linked List时间复杂度总结：prepend，append，insert，delete都是O（1），随机访问，lookup是O（n）。
- 10、Array的时间复杂度总结：prepend，append，lookup都是O（1），insert，delete是O（n）。
- 11、跳表，（skip list）只能用于链表中的元素有序的情况下
- 12、跳表对标的是平衡树，也就是二叉搜索树中的平衡树和二分查找。
- 13、一维数组要加速的方式就是升维，变成二维。
